"Name,Type,Pattern/Algorithm/Sub-type,Level,CTCI Num,URL,Date tested,Days Since Practiced,Times practiced,Time,Space,Notes ,See Problems,
Check Permutation,Arrays and Strings,,Easy,1.2,https://www.geeksforgeeks.org/check-if-two-strings-are-permutation-of-each-other/,1/9/2023,7,1,O(N),O(1),"first iterate over s1 storing chars as keys and the frequency of chars as values. Next iterate over s2, checking whether each char in s2 is not contained as a key in the hash, in which case return false, or, if char in s2 is in the hash, decrement the char's count in the hash.",,
Caeser's Cipher,Arrays and Strings,,Easy,1123,https://www.geeksforgeeks.org/caesar-cipher-in-cryptography/,1/10/2023,6,1,O(N),O(N),"input: string, number k. output: string. Init alphabet and encrypted word. Loop over the input string. Set the old index of the letter as alphabet.indexOf(char). Set the new index as (old index + k) mod 26. Append the new index'th element from the alphabet to the encrypted word string. return encrypted.",,
URlify,Arrays and Strings,,Easy,1.3,https://www.geeksforgeeks.org/urlify-a-given-string-replace-spaces-with-%20/,11/22/2022,55,3,O(N),O(1),"input: string. ouput: string. method 1: use javascript's replaceAll() method with a first input param of ' ' and a second input param '%20'. Method 2: use javascript's replaace() function with input params / /g, '%20'. Method 3: convert the string into an array. iterate over the array. if the char in the array is strictly equal to ' ' then call splice(i, 1, '%20'). Calling splice will delete the ' ' and insert the '%20' in its place.",,
Palindrome Permutations,Arrays and Strings,,Easy,1.4,https://leetcode.ca/all/266.html,1/4/2023,12,2,O(N),O(N),"Input: string. Output: bool. Convert input string into lowercase. Strip the spaces out with /\s/g, replacing with empty char. Init hash. Iterate over string. If each char in string is not an empty space, set char as key and frequency of key as value. Let value be current value + 1 or 1. Init odds state var. Loop through the keys of the hash. if the frequency (value) is not divisible by 2 then increment odds state var. Return whether or not odds is less than or equal to 1, since a palindrome has at most one char with an odd frequency. ",,
One Edit Away,Arrays and Strings,,Medium,1.5,https://leetcode.ca/all/161.html,11/24/2022,53,1,O(N),O(1),"inputs: two strings. output: bool. First check the lengths of string1, string2. If lengths are equal then call the checkEditOneAway helper. If lengths are different by +/-1, then check oneReplacementAway helper. ",,
Valid Palindrome,Arrays and Strings,palindrome,Easy,,https://leetcode.com/problems/valid-palindrome/,1/9/2023,7,3,O(N),O(1),loop over the string and check for equality between the front char and last char. if the two operands are not equal return false. Outside the loop return true.,,
Regex Replace Methods,Arrays and Strings,Regex,Easy,1123,1123,1/9/2023,1,1,O(N),O(1),remove spaces: /[\s]/g. Remove punctuation: /[^\w]/g. Remove all stuff except lower cases: /[^\w]/g...toLowerCase().,,
String Compression,Arrays and Strings,,Medium,1.6,https://leetcode.com/problems/string-compression/,12/26/2022,21,1,O(N),O(N),use count for state. compare str[x] and str[x+1]. append char count times to newString. reset charCount back to 0.,,
isUnique,Arrays and Strings,,Easy,1.1,https://www.geeksforgeeks.org/determine-string-unique-characters/,11/24/2022,53,1,O(N),O(N),"use hash to store chars as keys and a boolean as value. If the hash of a char is true, then the char is a repeat and the function returns false. Return true.",,
Rotate Matrix,Arrays and Strings,,,1.7,1123,1123,,,1123,1123,,,
Zero Matrix,Arrays and Strings,,,1.8,1123,1123,,,1123,1123,,,
String Rotation,Arrays and Strings,,,1.9,1123,1123,,,1123,1123,,,
Closest Value,Decrease and Conquer,,Medium,,https://www.geeksforgeeks.org/find-closest-number-array/,12/8/2022,39,1,O(log(N)),O(N),"- init start, mid, end idxs. Init closest as ∞.  Init hash and result array. Loop while startIdx is less than endIdx. Find the element at the current middle index. Calculate the difference between the element at the current middle index and the target. Then check if the present difference is smaller than the closest. The closest var represents the element from the array characterized by having the smallest difference with the input parameter called target. Set the closest var equal to the difference if the difference is smaller than closest. Also, add the element from the current middle position of the array as a key in the hash, where the value is the difference between the key and the target input value. Then, continue the binary search pattern. If the target input is greater than the middle element, move the start index one position past the current middle index, otherwise move the end index to the current middle position. Lastly, loop through the keys of the hash, storing keys whose value equals the closest var to into a result array. Return the 0th element from the array. ",Find k closest elements,
Euclid's Algorithm,Decrease and Conquer,,Medium,,https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/,12/4/2022,43,1,O(log(N)),O(1),"In the search for the greatest common divisor between two numbers a and b, where a is greater, then what the function must do is take the difference between a and b,  some c, then find the difference between b and c, then find the difference...and so on until the two numbers are (x, 0). When the second coordinate is 0 then x is the greatest common divisor of a and b. Loop while b > 0. Init temp var and declare temp equal to a - b. Then set [a, b] to [b, temp]. Return A which will be the GCD since it satisfies (A, O). ",,
Rotated Array Search,Decrease and Conquer,,Medium,,https://leetcode.com/problems/search-in-rotated-sorted-array/,12/28/2022,19,1,O(log(N)),O(1),"One side must always be sorted. Check it the target to the left or the right of the midIdx. Both sets of calls to shift the endIdx or startIdx are nested inside the logic that checks whether the left array is sorted or the right array is sorted. If the value at the start index is less than the value at the middle index, the left side must be sorted.",,
Peasant Multiplication,Decrease and Conquer,,Medium,,,1/10/2023,6,1,O(log(N)),O(1),Peasant multiplication works by initializing an accumulator variable. The function then initializes a while loop. Basically the function will cut the a var over and over and double the b var over and over. This process stops when a is 0 or lower. If a mod 2 is 1 then the accumulator increases by b. After each check of whether a mod 2 is 1 a is halved with parseInt and b is doubled. Return accumulator. ,,
Number of Ones,Decrease and Conquer,,Easy,1123,https://www.geeksforgeeks.org/count-1s-sorted-binary-array/,1/10/2023,6,2,O(log(N)),O(1),"Set start and end indexes. set the middle index to the result of the start index + (endindex - startIndex)/2. Be sure the second term endIdx - startIdx / 2 is parsed as an integer. If the element in the middle of the array being searched is 0, then set start index to the middle index plus on. Otherwise, look left by moving the end index to the middle index. At some point, start index + 1 will cause the while loop to terminate, as startIdx will be greater than endIdx. Return the result of the array's length less the start index. ",,
Greater Values,Decrease and Conquer,,Medium,,https://www.geeksforgeeks.org/find-the-number-of-elements-greater-than-k-in-a-sorted-array/,12/8/2022,39,1,O(log(N)),O(1),"Validate first. If the target is greater than the last element of input, return 0. Init three indices, start, mid, and end. Loop while the start is less than or equal to the end. As always the middle index will be the start index plus the result of parsing (end - start)/2. Compare the element at the middle index with the target in order to decide whether the target is greater than or equal to the middle element, which is when the start index location should change. If the target is not greater than the middle element then move the end index location. The while loop will terminate when the middle element will equal the target element, and start is incremented such that start exceeds end. After the while loop return the result of array.length less the middle index.",,
Square Root,Decrease and Conquer,,Easy,,https://www.geeksforgeeks.org/square-root-of-an-integer/,12/8/2022,39,1,O(log(N)),O(1),when updating start or end idx move to midIdx +/- 0.0000001. Apply .toFixed() method. Let mid be start + end / 2. ,,
Word Count,Frequency Count,,Easy,,,12/10/2022,37,1,O(N),O(N),"First, strip out the punctuation with regex replace on the expression /[^\w\s]/g. ",,
Uniques Only,Frequency Count,,Easy,,,12/10/2022,37,1,O(N),O(N),"Init accumulator array. Loop over the input arr. If the array does not include the element from the input arr, push the element into the array. return accumulator array. The return array must return only unique values;  no duplicates are allowed in the return array. // Method two. loop over array checking index of ele in the accumulator array and if index is -1 push ele into accumulator array then return accumulator. ",,
Missing Number,Frequency Count,,Easy,,,12/22/2022,25,1,O(N),O(N),"Loop from 1 to N, setting each value as the key to a hash and setting the key's value as 1 or 1 plus the current value. The resulting hash keeps track of numbers in the original array from 1 to N. Finally loop from 1 to N+1. If the value y from 1 to N+1 is not part of the hash, then push y to the result array. Return result array.",,
Two Sum,Frequency Count,,Easy,,,12/10/2022,37,1,O(N),O(N),"Put all of the array elements into a hash. Store array elements as keys and a true bool as value. Loop through the keys of the hash. If the result of the given sum in the input param minus the present key equals one of the other keys in the hash return true. If hash[target-key] === true) then the result of the target minus the key means there is a key in the hash, which, combined with the present key, equals the target. Return false. ",,
Letter Sort,Frequency Count,,Medium,,,12/22/2022,25,1,O(N),O(N),"The linear time solution uses arrays in a novel way and also uses unicode values. First convert the input string to all lowercase chars. Next, init chararacters array with 26 slots and fill the slots with 0s. Init result word. Loop over the lowercase string, setting the key at characters[string[ i ].CharCodeAt() - 97]  to be 1 or increase by 1. The 26-element array is set up for processing the characters in the input string. By doing CharCodeAtfor each letter, minus 97, the string increments the array elements. The array keeps track of the frequency of each letter in each of the 26 spots. So, ""abc"" would have an array [1, 1, 1....]. Finally, the return word pulls the letter from the array index, by doing String.fromCharCode(x+97), and then, doing .repeat on characters[ x ]. Finally, return the return word. ",,
Anagram Pair,Frequency Count,,Medium,,,12/10/2022,37,1,O(N),O(N),"*This function takes in two strings, string1 and string2, as input and check if they are anagrams. It first checks if the length of the two strings are equal, and if not, it immediately returns false. Then it creates two objects, hashN and hashM by calling the helper function charMapMaker and passing each of the input strings as an argument. This helper function loops through the characters in the passed string and adding them to the object as properties, with their value being the number of occurrences of that character in the string. Then, the main function loops through the properties of hashN, comparing the value of each property in hashN with the corresponding property in hashM. If any of these values are not equal, the function immediately returns false. If the function has not yet returned false, it means that the two input strings are anagrams of each other, and the function returns true.",,
Anagram Palindrome,Frequency Count,,Medium,,,12/10/2022,37,1,O(N),O(N),"This function takes in a single string as input and checks whether it can be reorganized to form a palindrome or not. It creates an empty object, hash, then loops through the characters in the passed string, adding them to the object as properties, with their value being the number of occurrences of that character in the string. Then it creates a variable oddsCounter initialized with 0 and loops through the properties of hash, and checks the value of each property, if it's not divisible by 2, then it increases the odds counter by 1. Finally, It compares the oddsCounter variable with 1, if it's greater then it returns false, which means that the input string cannot be reorganized to form a palindrome and if not then it returns true, which means that the input string can be reorganized to form a palindrome.",,
Bit Array Sort,Frequency Count,,Medium,,,12/22/2022,25,1,O(N),O(1),"This function sorts an array containing only 0s and 1s, by counting the number of zeroes in the input array using a variable zeroCount and then iterating over the array again to place the zeroes at the beginning of the array. The function then returns the sorted array.",Sort Integers by number of 1 bits,
Character Mode,Frequency Count,,Medium,,,1/11/2023,5,1,O(N) ,O(N),"This function sorts an array containing only 0s and 1s, by counting the number of zeroes in the input array using a variable zeroCount and then iterating over the array again to place the zeroes at the beginning of the array. The function then returns the sorted array.",,
Get Duplicates,Frequency Count,,Medium,,,12/22/2022,25,1,O(N),O(N),This function takes in an array of numbers and returns an array containing the duplicated elements present in the input array. The function creates a Hash map by iterating over the array and adding the elements as keys and their count as values. Then it iterates over the keys in the Hash map and only adds to the duplicatesArray if their count is greater than 1.,,
RGB,Frequency Count,,Medium,,,12/10/2022,37,1,O(N),O(N),"This function takes a string as input, it checks if the string has at least one occurrence of the characters 'r', 'g', 'b'. If it does not include any of those character, the function returns 0. Otherwise it creates a Hash map, iterating over the input string and counting the occurrences of each character. It then finds the minimum count of 'r', 'g' and 'b' from the Hash map, and returns it.",,
Sort Digits,Frequency Count,,Medium,,,12/23/2022,24,1,O(N),O(N),"This function takes an integer as an input, it sorts the digits of the number by building a hash table. The hash table stores the count of each digit in the input number. First the function uses a while loop to process the input number from right to left, by using the modulo operator to ""pop"" the digit off the number and storing the digit and it's count in the hash table. Then the function uses a for-loop to iterate through the hash table starting from the last index of digits which is 9 to 0. When it finds a digit that is present in the hash table, it multiplies that digit by an increasing power of 10( by using Math.pow(10,power) ) and adds it to the final result.",,
Graph class,Graph,Class method,Easy,,,01/09/23,7,1,O(1),O(N),This.storage is the only property on the graph class. The property is a hash map.,,
Add Vertex,Graph,Class method,,,,01/09/23,7,1,O(1),O(1),the addVertex(id) method is a member function of a graph class that takes a single argument id. it does the following: check if the vertex already exists in the storage using the given id. if it exists return false if it does not exist add the vertex to the storage with an empty array and return true.,,
Remove Vertex,Graph,Class method,,,,01/09/23,7,1,O(V+E),O(1),"The removeVertex(id) is a member function of a Graph class that takes a single argument, id.This function does the following steps: It checks if the vertex already exists in the storage using the given id. If it does not exist, it returns false. If it exists it loops through the storage, and for each vertex, it retrieves the edges in the storage and check if the id passed as parameter is present in the edges. If it is present it removes that edge using splice method, which removes the edge at a given index. Lastly, it deletes the vertex using the delete operator and returns true. This function is removing a vertex and all the edges that are connected to it on the graph.",,
Add Edge,Graph,Class method,,,,01/09/23,7,1,O(E),O(1),"The addEdge(id1, id2) is a member function of a Graph class that takes two arguments, id1 and id2. It does the following: It creates an empty array called vertexList. Iterates through the storage object and adds each vertex to the vertexList array. It checks if id1 and id2 exist in the vertexList array. If either one of them doesnt exist, it returns false. It adds the edge between id1 and id2 to the storage object and returns true. This function is adding an edge between two vertices in a Graph, It checks first if both id1 and id2 exist in the graph and if they exist it creates an edge between them.",,
Remove Edge,Graph,Class method,,,,01/09/23,7,1,O(1),O(1),"The removeEdge(id1, id2) is a member function of a Graph class that takes two arguments, id1 and id2. It does the following: It checks if id1 exists in the storage object, if it does not exist it return false. If it exists it retrieves the edges for the vertex, and checks if id2 is present as an edge. If it is present it removes that edge using the splice method, which removes the edge at a given index, then return true. If id1 doesn't exist in the storage object, it returns false. This function removes the edge between vertex id1 and id2, it checks if both vertices exist in the graph, if they exist it removes the edge between them.",,
Contains Vertex,Graph,Class method,,,,01/09/23,7,1,O(1),O(1),"The isVertex(id) is a member function of a Graph class that takes one argument id. It checks if a vertex exists in the storage object using the passed id, if it does exist it returns true, if not it returns false. This function is checking if a certain vertex is present in the graph or not by checking if it exists in the storage or not.",,
Find Neighbors,Graph,Class method,,,,01/09/23,7,1,O(1),O(E),"The neighbors(id) function is a member function of a Graph class that takes one argument id. It checks if the vertex exists in the storage object and if it does, it returns the edges for that vertex. If it does not exist, it returns null. This function allows to retrieve the neighbors of a certain vertex without modifying the graph storage.",,
Graph is a valid tree?,Graph,DS validation,,,,01/07/23,9,1,O(V+E),O(V),"return false if there are any islands. Use hash to track nodes which have been visited. If there is a node visited twice, then return false. The graphIsATree is a function that takes one argument graph which is supposed to be a graph. The function is checking if the given graph is a tree. It does the following: It checks for any islands by iterating through the graph object and for each vertex it checks if theres any edges, if theres none it returns false. It sets the root node as the first element in the graph object. Initializes a queue and a visited object. It performs a breadth-first search starting on the root node. For each node, it adds its edges to the queue and marks the node as visited in the visited object. If the loop ends and all the nodes have been visited it returns true, otherwise it returns false. This function is determining whether the input graph is a tree or not, it does that by checking if any vertices are disconnected from the graph and by checking if the graph is connected and doesnt have any cycles, if so, then its a tree, otherwise its not.",,
Binary Search Tree Validity,Hacking The Google Interview,BST-B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Axis Aligned Rectangle,Hacking The Google Interview,BST-A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Odd Man Out,Hacking The Google Interview,Frequency Count-B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Doubly Linked List,Hacking The Google Interview,A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Obstacle Avoidance,Hacking The Google Interview,Matrix - B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Maximal Subarray,Hacking The Google Interview,Moving Window- B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
TextEditor,Hacking The Google Interview,OOD-A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Queue Using Stacks,Hacking The Google Interview,Queues and Stacks - B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Minimum Stack,Hacking The Google Interview,Stack-A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
isSubstring?,Hacking The Google Interview,String-A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Design a Poker Game,Hacking The Google Interview,System Design-B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Leader Election,Hacking The Google Interview,System Design-B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Instant Messaging,Hacking The Google Interview,System Design-B,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Hash Table,Hacking The Google Interview,A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Coin Flipping and Die Rolls,Hacking The Google Interview,A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Target Sum,Hacking The Google Interview,A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Debugging,Hacking The Google Interview,A,,,http://courses.csail.mit.edu/iap/interview/materials.php,,n/a,0,,,,,
Linked List Palindrome,Linked List,Palindrome,Easy,2.6,https://leetcode.com/problems/palindrome-linked-list/,12/30/2022,17,1,O(N),O(1),For the constant space solution reverse second half of linked list. iterate from start and end to middle checking node equality,,
Swap List Nodes,Linked List,Dummy node,Medium,,,12/30/2022,17,1,O(N),O(1),"hunt for a and b within the linked list. use four state vars: currA, currB, parentA, parentB. ",,
Intersection of Two Linked Lists,Linked List,,Easy,2.7,https://leetcode.com/problems/intersection-of-two-linked-lists/,12/19/2022,28,1,O(N),O(N),"if aLength is greater than bLength, calculate difference and iterate from that difference away from the 0th position. ",,
Print Forward,Linked List,recursion/while loop,Easy,,,12/18/2022,29,1,O(N),O(N),"init current var as the head. while current is not null, log out current.value. ",,
Print Backward,Linked List,recursion,Easy,,,12/25/2022,22,1,O(N),O(N),"init helper function traverse. within the traverse helper method, recursively call traverse on current.next. inside helper method log current.value. Base case occurs when current is null. ",,
Reverse Linked List,Linked List,Dummy node,Easy,,https://leetcode.com/problems/reverse-linked-list/,12/27/2022,20,1,O(N),O(1),"init prev, current, and ref vars. set prev to dummy node. Traverse the list, setting the next pointer to the prev, then moving the three state vars over one position. ",,
Merge K Sorted Lists,Linked List,Merge sort/divide and conquer,Hard,,https://leetcode.com/problems/merge-k-sorted-lists/,01/01/2023,15,1,O(k*N(log(N)),O(1),"initialize the null node and set root to the null node. the helper method has both of these vars in scope. while the two list inputs to the helper function are not null if the list1.value is smaller than the list2.value append list1 via node.next and move the list1 pointer to list1.next, else, append list2 to node.next and move the list2 pointer to list2.next. use node = node.next to iterate over both helper method inputs. If one of the lists is null, append the rest of the other list as the node.next property. Set root to the 0th element of the lists input. Iterate over the lists input, setting root to the result of the helper method when the helper method has taken in root and lists[x]. After each loop the root will continue to update. ",,
Parens,Linked List,Stack,Easy,,https://leetcode.com/problems/valid-parentheses/,12/31/2022,16,1,O(N),O(1),"iterate over input string. if the symbol is an open paren, (,[, or {, then push the symbol to the stack. If the symbol is ), ], or }, and the stack length is not zero, and the element at stack[stack.length - 1] equals the corresponding open paren -- ( and ), [ and ], { and } -- then pop the last symbol from the stack. Return stack.length === 0. ",,
Remove Nth Node From End of List,Linked List,Dummy node,Medium,,https://leetcode.com/problems/remove-nth-node-from-end-of-list/,01/01/2023,15,1,O(N),O(1),"This function takes in a node and an integer n as its parameters. It performs the following steps: It creates a dummy node called dummy, which serves as a placeholder and it sets its next property to the input node. It initializes a variable length to 0, and another variable current to the input node. It enters a while loop that iterates as long as current is truthy, and in each iteration it increments length and sets current to the next property of the current current node. The while loop ends when current becomes falsy, which means all the next properties of the node is null, thus has been reached the end of linked list. if length is 1, the function sets the next property of dummy to null. it sets current to the input node again and calculates target as length - n. The function then enters a for loop that iterates from 0 to target and in each iteration, it checks if x is equal to target - 1. If it is, it sets the next property of the current current's next property to the next property of the current current's next property. Regardless of the if statement it sets current to the current's next property. Finally the function returns dummy.next which is the input node with the nth node from the end of the linked list removed. This function is removing the nth node from the end of a singly linked list, it does so by first calculating the length of the linked list using a while loop, then using another loop to iterate over the list and stopping at the node that is n nodes away from the end.",,
Serialize array into a linked list,Linked List,Arrays,Easy,,,12/25/2022,22,1,O(N),O(N),set value to the 0th array element. Init a class node with that value called root. Set a current var to the root node. Then iterate over the array. set each array value as the value of a node. Then set current.next to the newNode to point the list at the new node. Return the root.,,
Linked List Has A Cycle With Hash,Linked List,Freq. Count / hash tracking visits,Easy,2.8,https://leetcode.com/problems/linked-list-cycle/,12/18/2022,29,1,O(N),O(N),This solution compares nodes by value however the function passes all of the test cases on leetcode. Function uses frequency hash.,,
Linked List Has A Cycle,Linked List,Fast/slow pointers,Easy,2.8,https://leetcode.com/problems/linked-list-cycle/,1/2/2023,14,1,O(N),O(N),use a pointer which moves fast.next.next at each loop iteration and a slow pointer which moves at slow.next at each loop. return true if fast === true. ,,
Random Node Value,Linked List,,Medium,,https://leetcode.com/problems/linked-list-random-node/,12/18/2022,29,1,O(N),O(1),"use target = Math.floor(Math.random * length) to store random number between 0 and length. iterate over linked list until reaching the target. return target.value. To demonstrate randomness, store the results in a cache. The ele is the key, the number of occurrences is the value. Use a for loop to call the randomNodeValue() function. return the cache. ",,
Linked List Class Constructor,Linked List,Linked Link Class Methods,Easy,,,1/11/2023,5,1,O(1),O(1),"Call the constructor function with no input params. Set the three linked list class properties as the head, the tail, and the length.",,
Append,Linked List,Linked Link Class Methods,Easy,,,12/31/2022,16,1,O(1),O(1),"Call the insert method, with value and length as params to insert a node at the list's tail.",,
Insert,Linked List,Linked Link Class Methods,Easy,,,12/31/2022,16,1,O(N),O(1),"Create list node object. Change the head, tail, or both pointers depending on whether the link list's length is 0, if the insertion location is 0, if the insertion location is equal to the list's length, or if the insertion location is somewhere else. Change head and tail pointers when first or last node element is changing. ",,
Delete,Linked List,Linked Link Class Methods,Easy,,,12/31/2022,16,1,O(N),O(1),"This function is a method of a singly linked list data structure, it takes an index as an input and deletes the corresponding node from the list. The function first checks whether the index is within the range of the list's length, if not it return nothing. If the list's length is one, it sets the head and tail pointers to null. If the index is zero, it sets the head pointer to the next node. Otherwise, it uses a for loop to iterate over the list until the node before the one to be deleted is reached, then it ""deletes"" the node by removing the pointer at that node by making the pointer of the previous node to the next node of the node to be deleted. If the index of the element to be deleted is the last element of the list, it sets the tail pointer to the previous node. The function then decrement the length of the list by one.",,
Contains,Linked List,Linked Link Class Methods,Easy,,,12/31/2022,16,1,O(N),O(1),"This function takes a value as an input. Then, it sets a current var to point at the list's head. This is the variable used to iterate over the list in the while statement. While the current var is not null, return true if the current node's value equals the input value. If not, set current to current.next. If the whole list was looped over and there value was not discovered return false. ",,
List Node Class Constructor,Linked List,Singly Linked List Node Class,Easy,,,12/31/2022,16,1,O(1),O(1),Singly linked list nodes have value and next properties. Doubly linked list nodes have previous and next properties.,,
Linked List Remove From Tail ,Linked List,Stacks,,,,,,,O(N),O(1),"The method, named 'removeFromTail', removes the last node (also known as the 'tail') of the linked list, and returns the removed node. It first checks if the linked list is already empty and returns nothing in this case. If the length is 1, it remove the only head, tail and decrease the length of list by 1. If the length is greater than 1, it iterates through the list to find the second-to-last node, updates the tail reference to point to this node, and then sets the next reference of this node to null, thus removing the last node from the list. Lastly, it decrease the length of list by 1. The method will return the removed node in all of these cases.",,
Linked List Add To Tail,Linked List,Stacks,,,,,,,O(1),O(1),The addToTail(value) method instantiates a list node and attaches the node to the linked list. The linked list's length property increments. List currently has zero nodes? => head and tail property update. List currently has 1 node? => head.next and tail property change. List has more than one node? tail.next and tail property change.,,
Stack Class Constructor,Linked List,Stacks,Easy,,,12/31/2022,16,1,O(1),O(1),"The stack class's constructor function does not have input params, instead it instantiates this.linkedList as a new Singly Linked List(). ",,
Stack Class Push,Linked List,Stacks,,,,,,,O(1),O(1),"The push(value) method takes in a value and calls the linked list's add to tail method, passing in the value.",,
Stack Class Pop,Linked List,Stacks,,,,,,,O(N),O(1),The pop method has no inputs. The pop method calls the linked list's removeFromTail() and returns the popped node.,,
Merge Two Sorted Lists,Linked List,Dummy node ,Easy,,https://leetcode.com/problems/merge-two-sorted-lists/,01/01/2023,15,1,O(N),O(1),"This function takes in two parameters, list1 and list2, which are assumed to be singly linked lists that are already sorted in ascending order. It performs the following steps: It creates a dummy node called dummy and initializes a variable called tail to this node. It enters a while loop that iterates as long as both list1 and list2 are truthy. In each iteration, it compares the value of the list1 and list2 head, if the value of the list1 is less than or equal to the value of list2 it sets the next property of the tail node to the list1 head and move list1 head to its next node, otherwise it sets the next property of the tail node to the list2 head and move list2 head to its next node. It updates the tail node with the current tail's next property. If the first list is empty and the second is not, it sets the tail's next property to list2.If the second list is empty and the first is not, it sets the tail's next property to list1. Finally, the function returns the dummy.next which is the merged and sorted linked list. This function is merging two already sorted linked lists into a new sorted linked list. It does so by iterating over both linked lists and comparing their current nodes values and appending the smaller of the two to the result. It makes use of dummy head and tail pointers to keep track of the merging. It's a simple O(n) solution where n is the total number of nodes in both lists.",,
Skiplist Add,Linked List,Skiplist Class,Hard,,,01/02/2023,,,O(N),O(1),"This function adds a new node to a skip list data structure. It starts by initializing an array called 'update' with the same length as the current level of the skip list and all its elements set to null. Then it creates a variable called 'current' that points to the head of the skip list. The function loops through all the levels of the skip list, starting from the highest level, and for each level, it loops through all the nodes in that level and keeps moving forward until it finds a node with a key that is greater than or equal to the key being inserted. At each iteration of the inner loop, it assigns the current node to the corresponding position in the 'update' array. After the outer loop completes, the 'current' variable now points to the node which has the key either equal or immediately greater than the key being inserted. The function then checks if the key of the current node matches the key being inserted, if it does, it updates the value of the current node with the new value and returns. If the key is not found, it generates a random level using the randomLevel function and if the random level generated is greater than the current level of the skip list, it updates the 'update' array with the head node for all the levels greater than the current level and updates the current level of the skip list with the new level. Finally, it creates a new node using the SkipListNode class, and for each level, it updates the forward pointer of the corresponding node in the 'update' array to point to the new node and the forward pointer of the new node to point to the next node.",,
Skiplist Search,Linked List,Skiplist Class,Hard,,,01/02/2023,,,O(N),O(1),"This function searches for a node with a specific key in a skip list data structure. It starts by initializing a variable called 'current' that points to the head of the skip list. Then it loops through all the levels of the skip list, starting from the highest level, and for each level, it loops through all the nodes in that level and keeps moving forward until it finds a node with a key that is greater than or equal to the key being searched for. After the outer loop completes, the 'current' variable now points to the node which has the key either equal or immediately greater than the key being searched for. The function then checks if the key of the current node matches the key being searched for, if it does, it returns true, otherwise, it returns false.",,
Skiplist Delete,Linked List,Skiplist Class,Hard,,,01/02/2023,,,O(N),O(1),"This function deletes a node with a specific key from a skip list data structure. It starts by initializing an array called 'update' with the same length as the current level of the skip list, and all its elements are set to null. Then it creates a variable called 'current' that points to the head of the skip list. The function loops through all the levels of the skip list, starting from the highest level, and for each level, it loops through all the nodes in that level and keeps moving forward until it finds a node with a key that is greater than or equal to the key to be deleted. At each iteration of the inner loop, it assigns the current node to the corresponding position in the 'update' array. After the outer loop completes, the 'current' variable now points to the node to be deleted. The function then checks if the key of the current node matches the key to be deleted, if it does, it loops through all the levels again, and for each level, it checks if the forward pointer of the corresponding node in the 'update' array points to the current node, if it does, it sets it to the forward pointer of the current node. After that, the function decreases the level of the skip list by one until it reaches 0 or the head's forward pointer of that level is not null. Finally, it returns true if the node with the given key was found and deleted, otherwise, it returns false.",,
Skiplist Random Level,Linked List,Skiplist Class,Hard,,,01/02/2023,,,O(1),O(1),"This function generates a random level between 0 and a constant 'MAX_LEVEL'. It starts by initializing the level to 0 and then increments it while a random number generated is less than 0.5. Finally, it returns the minimum of the generated level and MAX_LEVEL as the final level.",,
Skiplist Constructor,Linked List,Skiplist Class,Hard,,https://leetcode.com/problems/design-skiplist/,01/02/2023,14,0,O(1),O(1),"This is a class definition for a SkipListNode, which has properties 'key', 'value', and 'forward', which is an array. In the constructor, it sets the key and value to either the provided value or null if no value is provided. It also creates an array of 'level + 1' length, filled with null values, and assigns it to the 'forward' property.",,
Reorder List,Linked List,,Medium,,https://leetcode.com/problems/reorder-list/,1/3/2023,n/a,0,O(N),O(1),"six vars: slow, fast, secondHalf, firstHalf, prev, ref. Apply the two-pointer technique to find the midpoint of the linked list. Name the pointers slow and fast. Init a reference to the second half of the list, called secondHalf, using slow.next. Then cut the list in half by setting slow.next to null. Make use of prev (set to null), ref (set to secondHalf.next), and secondHalf to reverse the second half of the linked list. Reverse the second half of the linked list by iterating while secondHalf is not null. Merge two lists, injecting the first node of the second reverse list right after the head of the initial first list. To merge two lists you need four things, the start of both lists, and also, you need references to both list's second nodes. So, you have the the first head initialized as firstHalf pointing at the head from the input params. You have the head of the reversed list redeclared as secondHalf pointing at prev. Then, you have two new vars inside the iterative loop. Ref1, which is initialized as the firstHalf.next and ref2 initialized as secondHalf.next. Set firstHalf.next to second half. Set secondHalf.next to ref1. Then continue to iterate by writing, firstHalf = ref1 and secondHalf = ref2.",,
Sum Lists // Add Two Numbers,Linked List,,Medium,2.5,https://leetcode.com/problems/add-two-numbers/,,,,,,,,
Remove Dups,Linked List,,,2.1,,,,,,,,,
Return Kth to Last,Linked List,,,2.2,,,,,,,,,
Delete Middle Node,Linked List,,,2.3,,,,,,,,,
Partition,Linked List,,,2.4,,,,,,,,,
Linked List to Queue,Linked List ,Queue,Easy,,https://www.geeksforgeeks.org/queue-linked-list-implementation/,12/31/2022,16,1,O(N),O(N),"Write out a linked list class with a list node and a linked list class. The data structure we are building is a queue, which follows a first-in, first-out police. The queue's enqueue method adds nodes to the tail of the data structure while the dequeue method removes nodes from the head of the data structure. ",,
LRU Cache,Linked List ,,Medium ,,https://leetcode.com/problems/lru-cache/,1/3/2023,13,1,O(1),O(1),"Write out a doubly linked list node class with key and value properties on it in addition to the next and prev pointers. The DLL node class takes in a key and value as params. Initialize the LRU class constructor by taking in a capacity param, and properties for size, map, head, tail, head.next, and tail.prev. To enforce the LRU policy, after every get or put call on a key, call moveToHead(key, node), which sends the node to the head of the list. Then, whenever there is a put(key, value) function call, and the new addition leads size to be greater than the capacity, evict the node presently at the tail by calling removeFromTail. In all, you will write the get(key), put(key,value), remove(node), moveToHead(key,node), addToHead(key,Node), and removeTail(). In Get(key), invoke moveToHead(key, node). In put(key, value),  invoke moveToHead(key, node), addToHead(key, xNode), and, if size exceeds capacity, removeFromTail(). ",,
Longest Substring Without Repeating Characters,Moving Window,Fast/Slow,Medium,,https://leetcode.com/problems/longest-substring-without-repeating-characters/,12/14/2022,33,1,O(N),O(N),"Init currentString and longestString. Use -1 index to indicate when a char is NOT included in a string. When a char is not already in a string, append the char to the string. If the char examined during the loop IS a repeat, then slice the current string from the position after the index of the char at X.",,
Bitflip advanced // Max Consecutive Ones III,Moving Window,Fast/Slow,Medium,,https://leetcode.com/problems/max-consecutive-ones-iii/,12/14/2022,33,1,O(N),O(1),"Let completedToggles start at zero and go up to the given n flips. Expand the right window edge until n 0s are found, which could be flipped. Contract once n 0s are found. Move the left pointer up until the left edge reaches a zero. After the left pointer reaches a zero, decrement availableToggles. Catch up when completedToggles exceeds n.",0,
Minimum Window Substring*,Moving Window,Fast/Slow,Hard,,https://leetcode.com/problems/minimum-window-substring/,12/15/2022,32,1,O(N),O(N),"This function, named ""bitFlipAdvanced"", takes in two arguments: an array ""arr"" of integers and an integer ""n"". It finds the maximum subarray length within ""arr"" that contains no more than ""n"" flipped bits (i.e. 0s). It does this by maintaining a sliding window, moving the right pointer to expand the window and counting the number of 0s within it. When the number of 0s exceeds ""n"", the left pointer is moved to shrink the window until the number of 0s is less than or equal to ""n"" again. The maximum length of the subarray is continually updated and returned at the end. The max is calculated as the max of either max itself or (right pointer - left pointer).",,
Trapping Rainwater Problem,Moving Window,Front/Back,Hard,,https://leetcode.com/problems/trapping-rain-water/,12/15/2022,32,1,O(N),O(1),"This function, named ""trapRainwater"", takes in an array ""array"" of integers. It calculates the amount of water that can be trapped between the bars of a histogram represented by the array. It does this by first initializing two arrays ""leftArr"" and ""rightArr"" with the first and last element of the input array respectively. Then, it iterates through the input array once, keeping track of the maximum value seen so far for both the left and right side of the array. Then, it iterates through the input array again and for each element it calculates the amount of water that can be trapped by taking the minimum of the maximum value seen so far for the left and right side and subtracting the current element from it. The result is added to a total which is returned at the end of the function.",,
Bitflip,Moving Window,Fast/Slow,Medium,,https://www.geeksforgeeks.org/maximize-number-0s-flipping-subarray/#practice,12/7/2022,40,1,O(N²),O(1),"This function, named ""bitFlip"", takes in an array ""array"" of integers. It finds the maximum number of 1s that can be obtained in the array by flipping 0s to 1s, and returns this maximum number. It does this by first initializing a variable ""original0Count"" to keep track of the number of 0s in the original array. Then, it iterates through the array twice. The outer loop starts at the first element of the array and consider all subarrays starting at that element. The inner loop starts at the same element as the outer loop and iterates through the array, counting the number of 1s and 0s in the current subarray. It calculates the difference between the number of 1s and 0s and updates the maximum difference seen so far. Finally, it returns the sum of the original number of 0s in the array and the maximum difference seen.",Bit Flip Advanced / Max Consecutive Ones III,
Consecutive Subarray Sum,Moving Window,Fast/Slow,Medium,,https://www.geeksforgeeks.org/find-subarray-with-given-sum/,12/14/2022,33,1,O(N),O(1),"This function, named ""consecutiveSubarraySum"", takes in an array ""nums"" of integers and an integer ""target"". It returns a Boolean indicating whether there is a contiguous subarray of the input array ""nums"" that has a sum of ""target"". It does this by using two pointers, i and j, initially set to 0 and a variable ""currentSum"" initialized to 0. The outer while loop continues until the currentSum is greater than the target. The inner while loop starts at the current value of j and iterates through the array while adding the element at index j to the currentSum. if the currentSum is equal to the target it returns true. otherwise, if the value of currentSum is greater than the target, it subtracts the current value of j from the currentSum and increments j. Once j reaches the end of the array, the outer loop increments i and continues until currentSum is greater than the target. If no such subarray is found, it returns false.",Continuous Subarray Sum (Leetcode 523);  Subarray Sum Equals K (Leetcode 560),
House Robber,Moving Window,Fast/Lagging,Medium,,https://leetcode.com/problems/house-robber/,12/15/2022,32,1,O(N),O(1),"This function, named ""houseRobber"", takes in an array ""array"" of integers representing the values of houses. It returns the maximum value that can be robbed from the houses without robbing any two adjacent houses. It does this by using a variable ""local"" to keep track of the current maximum value that can be robbed, a variable ""ultimate"" to keep track of the ultimate (overall) maximum value that can be robbed, a variable ""right"" that starts at 0 and a variable ""currentIdx"" that is initialized to 0. The outer while loop continues until the right pointer reaches the end of the array. Within the while loop, it sets the value of the local variable to the value of the current house at the right pointer. It then iterates through the array again with a nested for loop and if the difference between the current index and right pointer is greater than 1 and the difference between the current index and currentIdx pointer is greater than 1 as well, it adds the value of the current house to the local variable and updates the currentIdx pointer to the current index, this way it ensures that no two adjacent houses are robbed. Then it updates the ultimate variable with the maximum value between the current local variable and the ultimate variable. Finally, the outer while loop increments the right pointer and continues until the right pointer reaches the end of the array. The function returns the ultimate variable as the result.",,
K Unique Characters,Moving Window,Fast/Slow,Medium,,https://www.geeksforgeeks.org/find-the-longest-substring-with-k-unique-characters-in-a-given-string/,12/7/2022,40,1,O(N),O(N),"This function takes in a string as an argument, ""s"", and uses a sliding window technique to find the maximum substring length that contains no more than ""k"" unique characters. It first assigns the value of ""k"" by parsing the first character of the input string and assigns the rest of the string to a variable ""str"". It then initializes variables for the start and end of the window, the maximum length of the substring, the current count of unique characters, and a hash table to keep track of the characters in the current window. The function then iterates through the ""str"" variable and for each character, it checks if the character already exists in the hash table. If it does not, it increments the current count of unique characters and adds the character to the hash table. If it does exist, it increments the count of that character in the hash table. If the current count of unique characters is greater than ""k"", the function enters a ""catchup"" phase where it starts incrementing the start of the window until the count of unique characters is less than or equal to ""k"". It then updates the maximum length of the substring. The function returns the maximum length at the end.",,
Max Consecutive Sum,Moving Window,Fast/Catchup,Medium,,https://leetcode.com/problems/maximum-subarray/,12/13/2022,34,1,O(N),O(1),"Set local and ultimate vars to 0.Return ultimate. Loop from 0 to the end of the array. Set local to be local + array at index x, or, array at index x, whichever is greater. Then, set ultimate as the max of local and ultimate itself. ",,
Dungeon Escape (Tabulation),Moving Window,,Hard,,https://leetcode.com/problems/dungeon-game/,0,0,0,,,,,
Shortest Substring Window With 3 Characters,Moving Window,,Medium,,https://github.com/OutcoSF/outco-class-163/blob/main/whiteboarding/w2_d1_sliding_window/302_shortest_substring_with_3_unique_characters.md,0,0,0,,,,,
Longest Repeating Character Replacement,Moving Window,,Medium,,https://github.com/OutcoSF/outco-class-163/blob/main/whiteboarding/w2_d1_sliding_window/303_longest_repeating_character_replacement.md,0,0,0,,,,,
Flatten,Recursion,,Medium,,,12/13/2022,34,1,O(N),O(N),"Use Array.isArray( subarray[x] ) to check if the item in the current iteration is an array object. If the present element is an array object, call the helper method itself recursively. 1, create the state var flattened, an empty array. 2, return flattened. 3, define and invoke the helper method, makeFlat(subarray). The helper method runs a simple for loop over the input array. If the present element is an array, call the helper method on the element, otherwise push the element into the result array. ",,
Array pairs,Recursion,,Easy,,,12/12/2022,35,1,O(N),O(N),"1, create the state variable array, an empty array. 2. Return array. 3. Define and invoke the method pair(0). The method pair(depth) will first check for the base case: if the depth is greater than the input array length, return out. The function pushes [arr[depth], arr[depth+1]] as a tuple into the result array. The recursive call is stated as pair(depth + 2). ",,
Factorial,Recursion,,Easy,,,12/13/2022,34,1,O(N),O(N),"1, create the state var product. 2, return product. 3, define multiply(num) and invoke multiply(1). 4, The recursive action is to multiply product by the input num. The recursive call is on num+1. 5, The base case occurs when the input param number to the helper function is greater than the input param number for the factorial function itself, which is when the function returns out. ",,
Nth Fibonacci With Memoization*,Recursion,,Easy,,,12/24/2022,23,1,O(N),O(N),"1, Create the hash for caching. The helper method recursion does not exactly return the state var at the end of the function. Define the helper method as solve(num). The helper method first creates a key with num.toString(). Step 2. Read the cache during the recursive call. If the key exists in the cache, return the key's value. Define the base case for solve(num)  as being the case where if the input param num is less than 2 set the value for that key as the num and return hash[key] = num. The recursive call is to return hash[key] = solve(num - 1) + solve(num - 2). Invoke the helper solve(n). ",,
Nth Fibonacci With Pure Recursion,Recursion,,Easy,,,12/10/2022,37,1,O(2ⁿ),O(N),"use a ternary operator. If num is less than 2, reutrn num, else, call nthFibonacciPureRecursion(n - 1) + nthFibonacciPureRecursion(n - 2).",,
Number of Steps,Recursion,,Easy,,,12/10/2022,37,1,O(N) ,O(N),"1, create the state variable steps, 0. 2, Return steps. 3, Define traverse(x). There are two possible recursive calls for the function. If x is divisible by 2, increment steps by 1, and call traverse(x/2). If x is not divisible by two, increment steps and call traverse(x-1). Invoke traverse(num), where num is the input value. ",,
Power,Recursion,,Easy,,,12/10/2022,37,1,O(N),O(1),"1. Create the state var product. 2. Return product. 3. Define multiply(depth). Invoke multiply(0). 4. For the recursive case, multiply product by base, the input var. Call the helper multiply(depth + 1) recursively. 5. The base case: depth equals the exponent given in the function input parameters.",,
Powerset*,Recursion,,Easy,,,12/12/2022,35,1,O(2ⁿ),O(N),"This function takes a word as an input, and returns an array of all possible subsets (or ""powerset"") of that word. The function uses a recursive helper method called ""discoverCombos"" which takes two arguments, ""build"" and ""depth"". The base case of the recursion is when the depth is equal to the length of the input word, at which point the current ""build"" is added to the ""array"" state variable. On each recursive call, the function makes a binary decision to either include or exclude the letter at the current ""depth"" index in the ""build"". This continues until the base case is reached, resulting in all possible subsets of the input word being added to the ""array"" state variable, which is then returned by the function.",,
Powerset With Memoization*,Recursion,,Easy,,,12/11/2022,36,1,O(N),O(N),"This function takes a word as an input and uses memoization to return an array of all possible subsets (or ""powerset"") of that word. The function is similar to the previous one, it also uses a recursive helper method called ""discoverCombos"" which takes two arguments, ""build"" and ""depth"". The base case of the recursion is when the depth is equal to the length of the input word, at which point the current ""build"" is added to the ""array"" state variable. But, this function use a cache to save the state before to avoid repetitive calculation. On each recursive call, the function first checks the cache to see if the current subproblem has already been solved. If it has, the cached result is returned and the recursion for that branch ends. If not, the function continues as before, making a binary decision to either include or exclude the letter at the current ""depth"" index in the ""build"". The final result is the same as before, an array of all possible subsets of the input word is returned.",,
Print Array,Recursion,,Easy,,,12/10/2022,37,1,O(N),O(N),"This function takes an array as input and iterates over each element in the array by recursively calling a helper function called ""printEle"". The ""printEle"" function takes one argument, ""depth"" which represents the current index of the array. The base case for the recursion is when the ""depth"" is equal to the length of the array, at which point the function returns and the recursion ends. On each recursive call, the function prints the element at the current ""depth"" index of the array, and then calls ""printEle"" again with an incremented ""depth"" argument. This continues until the base case is reached and all elements of the array have been printed.",,
Print Reverse,Recursion,,Easy,,,12/10/2022,37,1,O(N),O(N),"This function takes an array as input and prints the elements of the array in reverse order using recursion. It uses a helper function called ""traverse"" which takes one argument ""depth"" that represents the current index of the array. On each recursive call, it prints the element at the index arr.length - 1 - depth of the array, and then calls ""traverse"" again with an incremented ""depth"" argument. The base case for the recursion is when the ""depth"" is equal to the length of the array, at which point the function returns and the recursion ends. This continues until the base case is reached and all elements of the array have been printed in reverse order.",,
Reverse String,Recursion,,Easy,,,12/10/2022,37,1,O(N),O(N),"This function takes a string as input and prints the characters of the string in reverse order using recursion. It uses a helper function called ""printChar"" which takes two arguments, the string and an index ""depth"" that represents the current position of the string. On each recursive call, it prints the character at the index ""depth"" of the string and then calls ""printChar"" again with a decremented ""depth"" argument. The base case for the recursion is when the ""depth"" is less than 0, at which point the function returns and the recursion ends. This continues until the base case is reached and all characters of the string have been printed in reverse order.",,
Climb Stairs ,Recursion,,Easy,,,12/25/2022,22,1,O(3ⁿ),O(N),"This function takes two inputs, n and jumps. n represents the total number of stairs in a staircase and jumps is an array of the possible steps that can be taken. The function uses a recursive approach to calculate the number of ways to climb the stairs by taking different steps from the array 'jumps'. It starts with a variable 'ways' initialized to 0, which will keep track of the total number of ways to climb the stairs. It uses a helper function called traverse which takes a single argument, build, representing the current number of stairs left to climb. The function has two base cases: if the build is less than zero, it returns 0, representing an invalid path. If the build is equal to zero, it increments the ways variable by 1, representing a valid path. Otherwise, the function makes a recursive call for each element in the jumps array. It decrements the build by the value of the jump and call traverse again until the base cases are reached. The final result is the value of the ways variable which will be the total number of ways to climb the stairs.",,
Lattice Paths*,Recursion,,Medium,,,12/12/2022,35,1,O(2ᵐ⁺ⁿ),O(M+N),"This function takes two numbers, row and col as inputs and calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with row columns and col rows, using a recursion (top-down) approach. It uses a recursive approach to calculate the number of unique paths from the top-left corner to the bottom-right corner of the grid. The function has two base cases: if row or col is less than zero, it returns 0, representing an invalid path. If the row and column are both zero, it returns 1, representing a valid path. Otherwise, the function makes two recursive calls, one traversing up and another traversing left. It calculates the number of paths from the current cell by traversing up and left, and returns the sum of the two recursive calls. The function uses a top-down approach because it starts at the endpoint and recursively breaks down the problem into smaller sub-problems.",,⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹
Lattice Paths with Memoization:,Recursion,,Medium,,,12/12/2022,35,1,O(M*N),O(M*N),"This function takes two numbers, m and n as inputs and calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with m columns and n rows, using a memoization (top-down) approach. It uses a recursive helper function called traverse which takes 2 arguments, row and col. The function also uses a cache object to store the results of previously calculated sub-problems. The base case for the recursion is when the row and column are both zero, it returns 1, representing a valid path. If the row or column is less than zero, it returns 0, representing an invalid path. It checks if the key of the current state is in the cache, if it's true, it returns the cached result. If not, it calculates the number of paths from the current cell by traversing up and left, and stores the result in the cache. This continues until the base case is reached, resulting in the total number of unique paths from the top-left corner to the bottom-right corner of the grid being returned. The function uses a top-down approach because it starts at the endpoint and recursively breaks down the problem into smaller sub-problems.",,ᵃ ᵇ ᶜ ᵈ ᵉ ᶠ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᶻ
Lattice Paths with Tabulation:,Recursion,,Medium,,,12/12/2022,35,1,O(M*N),O(M*N),"This function takes two numbers, x and y as inputs and calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with x columns and y rows, using a tabulation (bottom-up) approach. It creates a foundation of a 2D array filled with 1's and then loops through each element of the array, updating the value of each element with the sum of the element above it and the element to the left of it. The final result is the last element of the array, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid. The function only uses a single array to store the state and uses two nested loops to traverse through the grid in a bottom-up fashion, which is why it's called tabulation.",,✓
Capital Permutations,Recursion,,Medium,,,12/13/2022,34,1,O(2ⁿ),O(2ⁿ),"This function takes a string as input and returns an array of all possible permutations of that string with both uppercase and lowercase variations of each character. The function uses a recursive helper method called ""generatePermutations"" which takes two arguments, ""str"" and ""depth"". The base case for the recursion is when the depth is equal to the length of the input string, at which point the current ""str"" is added to the ""permutations"" state variable. On each recursive call, the function gets the character at the current ""depth"" index of the input string, converts it to uppercase and lowercase and calls generatePermutations again with ""str"" concatenated with uppercase and lowercase character and an incremented ""depth"" argument. This continues until the base case is reached, resulting in all possible permutations of the input string with both uppercase and lowercase variations of each character being added to the ""permutations"" state variable, which is then returned by the function.",,
Capital Permutations Advanced - array implementation,Recursion,,Medium,,,12/13/2022,34,1,O(2ⁿ),O(2ⁿ),"This function takes a string as input and returns an array of all possible permutations of that string with both uppercase and lowercase variations of each letter and digits remain the same. The function uses a recursive helper method called ""generatePermutations"" which takes two arguments, ""build"" and ""depth"". The base case for the recursion is when the ""depth"" is equal to the length of the input string, at which point the current ""build"" is added to the ""permutations"" state variable. On each recursive call, the function checks if the current character is a number, if it's true, it concatenates the build string with the number and calls the generatePermutations again with incremented depth. If the current character is not a number, it converts it to uppercase and lowercase and calls generatePermutations again with ""build"" concatenated with uppercase and lowercase character and an incremented ""depth"" argument. This continues until the base case is reached, resulting in all possible permutations of the input string with both uppercase and lowercase variations of each letter and digits remain the same being added to the ""permutations"" state variable, which is then returned by the function.",,
Capital Permutations Advanced - Set implementation,Recursion,,Medium,,,12/13/2022,34,1,O(2ⁿ),O(2ⁿ),"This function takes a string as input and returns a set of all possible permutations of that string with both uppercase and lowercase variations of each letter, and digits remain the same. The function uses a recursive helper method called ""generatePermutations"" which takes two arguments, ""build"" and ""depth"". The base case for the recursion is when the ""depth"" is equal to the length of the input string, at which point the current ""build"" is added to the ""permutations"" state variable which is a set. On each recursive call, the function checks if the current character is a number, if it's true, it concatenates the build string with the number and calls the generatePermutations again with incremented depth. If the current character is not a number, it converts it to uppercase and lowercase and calls generatePermutations again with ""build"" concatenated with uppercase and lowercase character and an incremented ""depth"" argument. This continues until the base case is reached, resulting in all possible permutations of the input string with both uppercase and lowercase variations of each letter and digits remain the same, being added to the ""permutations"" state variable, which is then returned by the function.",,
Count Vowel Strings,Recursion,,Medium,,,12/13/2022,34,1,O(5ⁿ),O(N),"This function takes a number as input and returns the total number of strings that can be generated by using the vowels 'a', 'e', 'i', 'o', 'u' repeatedly for a number of times equal to the input number. It uses a recursive helper function called ""generateString"" which takes two arguments, ""build"" and ""depth"". The base case for the recursion is when the ""depth"" is equal to the input number, at which point the current ""build"" is added to the ""array"" state variable. On each recursive call, the function loops over each vowel and calls ""generateString"" again with the current ""build"" concatenated with the current vowel and an incremented ""depth"" argument. This continues until the base case is reached, resulting in all possible strings generated by the vowels being added to the ""array"" state variable. The final result is the length of the array, which is the total number of strings that can be generated.",,
Merge Sorted Arrays,Recursion,,Medium,,,12/12/2022,35,1,O(M+N),O(M+N),"This function takes in two sorted arrays as input and returns a new array that contains all the elements from both input arrays in sorted order. It uses two pointers, one for each input array, to iterate over the elements of both arrays. It uses a while loop to check if the pointer for any array has reached the end of the array. In each iteration of the while loop, it compares the element at the current pointer index of each array and pushes the smaller element to the merged array. After the while loop, it checks if there are any elements left in either input array and pushes them to the merged array one by one. In the end, it returns the merged array which contains all the elements of both input arrays in sorted order.",,
Non-Consecutive Ones,Recursion,,Medium,,,12/12/2022,35,1,O(N),O(N),"This function generates all possible binary strings of a given length (passed as the ""number"" parameter) where no two ""1""s are consecutive. It uses recursion to generate all possible combinations by adding a ""0"" or a ""1"" to the current string, called ""build"". The recursion terminates when the length of the ""build"" string is equal to the input ""number"" or if the ""build"" string contains ""11"" in it. The final result is an array of all possible combinations that meet the criteria, stored in the ""result"" variable.",,
Non-Consecutive Ones Advanced:,Recursion,,Medium,,,12/12/2022,35,1,O(N),O(N),"This function generates all possible binary strings of a given length (passed as the ""n"" parameter) where no two ""1""s are consecutive. It uses recursion to generate all possible combinations by adding a ""0"" or a ""1"" to the current string, called ""substring"". The recursion terminates when the length of the ""substring"" is equal to the input ""n"". The function also has an optimization where it only adds a ""1"" to the substring if the last character of substring is not ""1"". The final result is an array of all possible combinations that meet the criteria, stored in the ""array"" variable.",,
Nth Fibonacci With Side Effects,Recursion,,Medium,,,12/10/2022,37,1,O(N),O(N),"This function calculates the nth number in the Fibonacci sequence, where ""n"" is passed as the ""number"" parameter. It uses recursion and side effects to track the current index ""i"" and the sequence ""fibonacci"" so far. If the input number is less than 2, it returns the corresponding number from the ""fibonacci"" array. Otherwise, it adds the last two numbers in the ""fibonacci"" array, adds the result to the array, and calls the function again with the updated ""i"" and ""fibonacci"". If ""i"" is equal to the input ""number"", it returns the last number in the ""fibonacci"" array.",,
String Permutations,Recursion,,Medium,,,12/24/2022,23,1,O(N!),O(N!),"This function takes in a string as an argument, and returns all permutations of that string using a technique called memoization. It uses a set object to store the permutations and a hash object to store the results of previously calculated permutations. The function uses recursion and memoization to avoid recalculating the same permutations. It starts by calling the buildPermutation function with an empty string and an empty array of used indexes, and for each character in the original string, it checks if the index has not been used yet and if so, it calls the buildPermutation function again with the new permutation and the used indexes. The function returns a set containing all permutations of the original string.",,
Tower of Hanoi,Recursion,,Medium,,https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/,,,1,O(N),O(N),"This function is an implementation of the Tower of Hanoi problem using an arrow function and a helper function. The helper function moveDiscs takes four parameters: num, source, auxiliary, and target and it's responsible for the recursion process. The main function towerOfHanoi takes the same parameters as the helper function and it's calling the helper function passing the parameters, and it's returning the result of calling the helper function. The logic of the function is the same as the previous implementation, where the base case is when num equals to 0, in this case, there are no disks to move, otherwise, the function first moves num - 1 disks from source to auxiliary peg using recursion, then it moves the numth disk from source to target peg, and finally, it moves the num - 1 disks from auxiliary to target peg using recursion again. The function will work as expected and will output the expected result.",,
Climb Stairs with Tabulation,Recursion,,,,,,n/a,0,,,,,
Search in a BST,Trees,Helper method recursion.,Easy,,https://leetcode.com/problems/search-in-a-binary-search-tree/,01/03/23,13,2,O(N),O(1),"- Helper method recursion. Define traverse method. If the node is null, return false. If the current node's value equals the input target value, return true. If the input value is less than the present node, call traverse on the left child node. If the input value is greater than the present node, call traverse on the right child node. Make sure to return the values of the recursive calls. Invoke the helper method with the tree and input valued as params.",,
Insert into a BST,Trees,Helper method recursion.,Medium,,https://leetcode.com/problems/insert-into-a-binary-search-tree/,01/05/23,1,2,O(N),O(1),"- Helper method recursion. Special case: if the root is null, set xNode as the root. define traverse. if the insertion value is greater than the present node value, traverse right. If the insertion value is less than the present node value, traverse left. If the insertion value is greater than the present node value, and the right child is null, set the xNode(w/insertion value) as the node.right leaf. If the insertion value is less than the present node, and, the present node's left leaf is empty or null, set the node.left property to the xNode. ",,
Tree Node Class,Trees,,Easy,,,01/03/23,13,1,n/a,O(1),"- value, left, right properties",,
Validate Binary Search Tree,Trees,HTGI; in-order DFS; DS validation,Medium,4.5,https://leetcode.com/problems/validate-binary-search-tree/,01/04/23,12,,O(N),O(N),"Helper method recursion: 1, init array; 2, init loop to check arr[x] < arr[x+1]; 3, define inorderTraversal.  4, base: if node is null, return. 5, recursive: call self on left leaf, push/visit present node, call self on right leaf. Since the pattern is LAR, we say this is in order dfs traversal. ",,
Longest Binary Tree Path a.k.a. Maximum Depth of a Binary Tree,Trees,Pre-order DFS,Easy,,https://leetcode.com/problems/maximum-depth-of-binary-tree/,01/04/23,12,1,O(N),O(1),"if the root node is null return 0. A root node being null is the base case. Recursively call maxDepth() on the left and right leaves of the root. Return Math.max(leftPath,rightPath) + 1. ",,
Deserialize Array Into A BT ,Trees,,,,,,1/16/2023,,,,"This function takes an array as an input and deserializes it into a binary tree. It first checks if the input array is empty, if so it returns null. Otherwise, it instantiates a new TreeNode object with the value of the first element of the array as the root of the tree. It then creates a queue and pushes the root into it. It then enters a for loop that starts at index 1 and goes through the array in pairs. For each iteration, it takes the first element from the queue, which is the current node being processed. If the current element of the array is not null, it creates a new TreeNode with the current element's value, assigns it as the left child of the current node, and pushes it into the queue. Similarly, if the next element of the array is not null, it creates a new TreeNode with the next element's value, assigns it as the right child of the current node, and pushes it into the queue. This process continues until all elements of the array have been processed and a binary tree is constructed using the input array. The root of the tree is returned.",See the problem where an unsorted array is deserialized into a regular binary tree. ,
Convert Sorted Array into a BST,Trees,,Easy,4.2,https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/,,1/16/2023,,,,,,
Lowest Common Ancestor,Trees,pre-order DFS  + H.M.R.,Easy,,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/,,1/16/2023,,O(N),O(N),"helper method recursion. 1. state vars: common, path, path1, path2. push node.value into path. if the node val equals num1, copy the path into path1 arr. if node val equals num2, copy the path into path2 arr. while path1[x] equals path2[x] set common to path1[x]. Increment x. Return common. Traverse from root the target nodes, storing the values of the visited nodes into arrays. compare arrays, iterating over both. If the elements are different, return the previous common array value. ",,
BFS Traversal,Trees,Queue processing,Medium,,,01/14/23,2,,O(N),O(N),"This function takes a binary tree as an input and performs a Breadth-first Search (BFS) traversal on it, returning an array of the values of each node in the tree in the order they were visited. It starts by initializing an empty array called 'queue' and an empty array called 'result'. It pushes the root of the tree into the queue. If the root is null, the function returns an empty result array. It then enters a while loop that continues until the queue is empty. It takes the first element of the queue and assigns it to a variable called 'current'. It then pushes the value of the current node into the result array. If the current node has a left child, it pushes it into the queue. If the current node has a right child, it pushes it into the queue. This continues until all nodes in the tree have been visited, and their values have been added to the result array. The function returns the result array which contains the values of the nodes in the tree in the order they were visited using BFS.",,
Invert a Binary Tree,Trees,pre-order DFS + H.M.R.,,,https://leetcode.com/problems/invert-binary-tree/,1/4/23,12,2,O(N),O(N),"- do stuff with present node, call function to do stuff with left and right nodes. Store the right and left nodes in vars, x1 and x2. Set the left node property as x2 and set the right node property as x1. ",,